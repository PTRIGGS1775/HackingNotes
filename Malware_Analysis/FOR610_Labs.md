# REadme

You don't need to write down lab answer. Just do the labs from the book. DOn't need to copy the lab details either.

# Lab 1.1
Step 1: Extract ASCII and Unicode strings embedded into brbbot.exe.
Use the command-line tool pestr on REMnux to extract strings from brbbot.exe. Review the output to identify strings that might reveal details about the nature of this specimen, and that could present potential IOCs.

```md
- I used floss and found a couple interesting strings that indicate a call to a C2 server, persistence in the run registry and potential cryptography.

Software\Microsoft\Windows\CurrentVersion\Run
brbbot
Microsoft Enhanced Cryptographic Provider v1.0
Mozilla/4.0 (compatible; MSIE 8.0; Windows NT 6.1; Trident/4.0)
HTTP/1.1
Connection: close

```

Step 2: Spot anomalous aspects of brbbot.exe.
Use PeStudio on Windows REM Workstation and peframe on REMnux to examine key aspects of brbbot.exe and spot anomalous characteristics.

```md
- Similar efforts noted as with strings, but also noted that the exe was not packed.
```

# Lab 1.2
Step 1: Launch Process Hacker and Process Monitor on Windows REM Workstation.
Launch Process Hacker on your Windows REM Workstation. Look at the listing of the running processes to gain familiarity with the system's state before you infect it. Then, launch Process Monitor on the same virtual machine, pause its capture (Ctrl+E), and clear its log file (Ctrl+X).

Step 2: Launch Regshot and take the first snapshot using this tool on Windows REM Workstation.
Launch Regshot on the Windows REM Workstation and take the first snapshot by pressing 1st shot > Shot.

Step 3: Launch Wireshark on REMnux and start its capture.
On REMnux, run the following command in the terminal window. The & at the end of the command directs the terminal to place the application in the background, so you can use the same terminal window to issue other commands:


wireshark &
Once Wireshark launches, activate its capture by double-clicking the “ens33” line or by pressing Ctrl+E. Leave Wireshark active and go back to your Windows REM Workstation virtual machine.

Step 4: Activate monitoring in Process Monitor and infect Windows REM Workstation with brbbot.exe.
Activate monitoring in Process Monitor via Ctrl+E on Windows REM Workstation. Double-click the Brbbot shortcut to infect the virtual machine. Process Hacker should display the malicious brbbot.exe process running on the system.

Step 5: Terminate the brbbot.exe process and stop capture in Process Monitor.
Use Process Hacker to terminate the brbbot.exe process on Windows REM Workstation. To do this, right-click the running brbbot.exe process and select Terminate. Stop capture in Process Monitor (Ctrl+E).

Step 6: Stop capture in Wireshark.
Switch to the REMnux virtual machine. Press Ctrl+E in Wireshark to pause its capture.

Step 7: Take the second Regshot snapshot and compare it to the first one, examining Regshot's report.
Create the second Regshot snapshot on Windows REM Workstation (2nd shot > Shot). Generate the Regshot comparison report (Compare). Examine the Regshot comparison report to spot interesting changes.

Step 8: Analyze Process Monitor's log file using ProcDOT.
Save the Process Monitor log file as a CSV file. Launch ProcDOT on the Windows REM Workstation.

Load the Process Monitor log file into ProcDOT by clicking the "…" button in the Procmon area. Press the "…" button in the Launcher area and designate brbbot.exe as the "first relevant process."

Direct ProDOT to generate the diagram of the log files' contents by clicking the Refresh button and examine it to get a better sense for what happened when the system was infected with brbbot.exe.

Step 9: Examine Wireshark's log file.
Switch to REMnux and examine the Wireshark log to spot the suspicious DNS request.

After reviewing the logs, switch to the Windows REM Workstation virtual machine and exit ProcDOT and Process Monitor. You can keep Wireshark running (but not capturing) on REMnux, because it will be used in the next exercise. You can leave Process Hacker running as well.

# Lab 1.3
Step 1: Launch fakedns on REMnux and confirm that it is working.
Run the fakedns command on REMnux. Then, go to the Windows REM Workstation virtual machine, open a Command Prompt, and run nslookup. Attempt to resolve any hostname, such as "example.com." In response, you should see the IP address of your REMnux virtual machine. If you don't, reboot the REMnux virtual machine and run fakedns again; then, confirm that you've configured network settings of your Windows REM Workstation virtual machine according to instructions in Lab 0.2.

Step 2: Start a new capture in Wireshark on REMnux, and then reinfect Windows REM Workstation with brbbot.exe.
Launch Wireshark on REMnux, if it isn't already running. Start capturing network packets (Ctrl+E). Then reinfect your Windows REM Workstation virtual machine with brbbot.exe. Process Hacker should display the running malicious process. On REMnux, fakedns should display the specimen attempting to resolve a hostname.

Step 3: Terminate brbbot.exe and stop capture in Wireshark, and then examine the log.
Terminate the brbbot.exe process using Process Hacker on Windows REM Workstation after approximately half a minute. Stop capture in Wireshark (Ctrl+E) on REMnux. Examine the network traffic captured by Wireshark.

Step 4: Start the web server on REMnux, activate capture in Wireshark, and then reinfect Windows REM Workstation with brbbot.exe.
Keep fakedns running on REMnux. Open a new terminal tab on REMnux and start the web server there by typing the following command:


httpd start
Go to your Windows REM Workstation, open Internet Explorer, and manually visit http://brb.3dtuts.by to confirm that fakedns and the web server run properly. If you get an error, confirm that both tools run and, if necessary, validate your lab's network configuration to match the directions in Lab 0.2.

Start capturing network traffic in Wireshark on REMnux (Ctrl+E), and then reinfect your Windows REM Workstation with brbbot.exe.

Step 5: Terminate brbbot.exe and stop capture in Wireshark, and then examine the log.
Terminate the brbbot.exe process using Process Hacker on Windows REM Workstation after approximately half a minute. Stop capture in Wireshark (Ctrl+E) on REMnux. Examine the network traffic captured by Wireshark. You should be able to see an established HTTP session; examine its payload by right-clicking one of its packets, and then selecting Follow TCP Stream.

Step 6: Save the encoded payload from the HTTP traffic for later analysis.
While looking at the HTTP session's payload in Wireshark's Stream Content window, select the hexadecimal characters that follow &p=, right-click, and then click Copy to copy these contents to the clipboard.

Switch to a terminal window on REMnux and type the following command:


code encoded.hex
In the Visual Studio Code editor, paste contents of the Clipboard via Edit > Paste (Ctrl+V). Then save the file (Ctrl+S) and exit the text editor (File > Exit). Confirm that the file you created has the expected contents by examining it using the following terminal command:


cat encoded.hex
Exit Wireshark by selecting File > Quit (Ctrl+Q).

# Lab 1.4
Step 1: Use the speakeasy command to emulate the execution of brbbot.exe in Speakeasy, saving the JSON output to speakeasy.json and the stderr output to speakeasy.txt.
Use the speakeasy command to emulate the execution of brbbot.exe in Speakeasy. To do that, run the following command in your terminal on REMnux from the ~/malware/day1 directory, where the previously extracted brbbot.exe file is located:

speakeasy -t brbbot.exe -o speakeasy.json 2> speakeasy.txt

The parameter -t brbbot.exe specifies the execution of which file you want to emulate in Speakeasy. The parameter -o speakeasy.json directs Speakeasy to save its output using the computer-friendly JSON format to the file speakeasy.json. The script sends the rest of its output to stderr; the directive 2> speakeasy.txt sends this output to the file speakeasy.txt.

Step 2: Use Visual Code Studio to examine speakeasy.txt and identify interesting API calls.
Next, load the speakeasy.txt file in Visual Code Studio:


code speakeasy.txt
Examine that file to get API-level visibility into brbbot.exe operation. Consider:

What interesting API calls do you spot, which correspond to your earlier behavioral observations?
Why does the emulator halt its operation in a way that seems premature?
As you scroll through the speakeasy.txt file in Visual Code Studio, note the first CreateFileA API call, which attempts to open a handle to brbconfig.tmp with the ability to read from and write to that handle. The statement -> 0x80 the end of that line indicates that the emulator assigns handle number 0x80 to that handle.

Two lines later, note the WriteFile API call, which specifies handle 0x80 as the destination of the operation. That's the handle from the earlier CreateFileA call, which suggest that the specimen would try to write to brbconfig.tmp if it were running in a real environment (note the inclusion of GENERIC_WRITE and CREATE_ALWAYS flag).

A bit later, the output of Speakeasy includes another instance of CreateFileA, which is also directed at brbconfig.tmp. In this case, the specimen expects to open an existing file (note the OPEN_EXISTING flag). This is probably an attempt to read the generated brbconfig.tmp file, so that the specimen can examine its contents.

Note the following statement at the end of the speakeasy.txt file:


Unsupported API: ADVAPI32.CrypteDestroyKey
This message indicates that Speakeasy encountered an unfamiliar API call (CrypteDestroyKey), which it couldn't emulate. Unsure how to proceed, the emulator halted, without giving you visibility into what the specimen would've done calling CrypteDestroyKey. This is a common limitation of emulators.

Step 3: Time-permitting, use the jq command to extract just the API names from speakeasy.json.
Use a command such as more speakeasy.json to become familiar with the schema of Speakeasy JSON output. While the discussion of the JSON file format and the use of the JSON parsing tool jq is outside the scope of the course, you can preview its capabilities by using the following command to extract just the API names from speakeasy.json:


jq ".entry_points[].apis[].api_name" speakeasy.json | more
Step 4: Use capa to identify key capabilities of brbbot.exe and gain visibility into the APIs the specimen uses to implement them.
Use the following command on REMnux to emulate the execution of brbbot.exe using capa:


capa brbbot.exe | more
Examine the tool's output to determine:

Which characteristics reinforce what you know about the specimen already?
Which expand your understanding of its capabilities?
For example, note the references to the ability of the specimen to modify the registry and interact with the file system, which we observed earlier. Similarly, note that capa reports that brbbot.exe can send and receive data, which is consistent with our earlier observations as well. The tool points out that the network interactions could be used for Command and Control (C2), which might not have been obvious to all analysts from earlier observations.

To gain a more detailed perspective on the specimen's capabilities, supply capa with the parameter -vv like this:


capa -vv brbbot.exe | more
Note that now the emulator shows the full context for the identified capabilities, displaying the name of the corresponding API call and the location in the code that invoked that function.

# Lab 1.5
Step 1: Load brbbot.exe into x64dbg and set a breakpoint on ReadFile.
On the Windows REM Workstation, load C:\Users\REM\AppData\Roaming\brbbot.exe into x64dbg (File > Open). Don't run the specimen within the debugger just yet; the debugger will display "Paused" in the bottom-left corner of the CPU tab.

If there is time, load brbbot.exe in PeStudio, navigate to the "imports" area, and confirm that ReadFile is present in the symbols listing. Then, switch back to the x64dbg window.

Type the following command in the Command window at the bottom of x64dbg's CPU tab to set a breakpoint on the ReadFile API call:


SetBPX ReadFile
Remember to press Enter after typing the command.

Step 2: Confirm that the specimen is using ReadFile to read brbconfig.tmp.
Run the specimen in x64dbg by pressing F9 or selecting Debug > Run. The specimen will pause shortly at the breakpoint you've just defined.

When paused at the beginning of the ReadFile function, confirm that the specimen is reading from the brbconfig.tmp file. To do this, glance at the area on the right side of x64dbg's CPU tab that shows function parameters. The first parameter should be RCX. The value stored there represents the parameter named hFile, which was passed to ReadFile (e.g., "108").

Bring up the Handles tab in x64dbg, right-click, and select Refresh. Then, locate the handle that corresponds to the parameter value you're investigating (e.g., "108"). You should see that it points to the brbconfig.tmp file.

Step 3: Decrypt brbconfig.tmp by setting and triggering a breakpoint after the call to CryptDecrypt.
Return to x64dbg's CPU tab. Select Debug > Run to user code or press Alt+F9. This will allow ReadFile to finish executing.

Once x64dbg pauses the specimen's execution, scroll down to the instruction that calls CryptDecrypt. Select the test eax,eax instruction after that call, then select Debug > Run until selection or press F4.

Once paused, glance at the Stack region in the bottom-right corner of the debugger's CPU tab and make a note of the long ASCII string whose address is stored at the top of the stack. The string's contents start with uri=ads.php. These appear to be decrypted contents of the brbconfig.tmp file.

Step 4: On REMnux, use CyberChef to decode the exfiltrated web session payload, which was captured earlier.
Recall that in Lab 1.3, you saved some of the data that brbbot.exe sent from the infected system into the encoded.hex file. Now you can decode the contents of that file using the common implementation of an XOR-based algorithm and the key 0x5B.

To do this, first launch CyberChef on REMnux from the terminal window:


cyberchef
Once Firefox opens with the CyberChef app, load the encoded.hex file into CyberChef by following these steps:

Click the "Open file as input" button in the Input region.
Navigate to the encoded.hex file (it might be in the remnux user's home directory), select the file, and click the Open button
Next, decode contents of encoded.hex, which should now be in the Input region of CyberChef. To do that, build a recipe that first decodes the input from hex, then deobfuscate it using XOR with the key 5b:

In the Operations region of CyberChef, find the From Hex operation, click on it (without letting go of the mouse), and drag it to the Recipe region.
In the Operations region of CyberChef, navigate to the Encryption / Decoding section, find the XOR operation, click on it (without letting go of the mouse), and drag it to the Recipe region.
Specify the deobfuscation key by typing 5b into the Key area of the XOR recipe step. This is the key you discovered earlier after decrypting the brbconfig.tmp file.
CyberChef will automatically apply the recipe, displaying legible contents in the Output region. Examine the deobfuscated contents and observe the data that the specimen was exfiltrating.

