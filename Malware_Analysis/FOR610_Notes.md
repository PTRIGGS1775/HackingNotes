# FOR610

This page is designed to keep track of all relevant commands and tools during the FOR610 course. This is organized by course days but will be sorted by task details later.

- Use your lab to examine the network traffic and packet. Then use a connected machine in the cloud, perhaps a tails instance to pull the malware. To take it a step further you could purchase the space with gift cards.
- Malware bazaar is a place to look at malware samples or github malware repo (the zoo) or vx underground or [malware-traffic-analysis](https://www.malware-traffic-analysis.net/).

## Certification tips
- https://www.giac.org/certifications/reverse-engineering-malware-grem/
- You will be asked to apply your knowledge.
- Do your labs multiple times.
- Create a good index
- You'll get two practice tests. Get yourself ready first before taking practice tests.
- APIs should be in your index

FYI, Exam Takers
- You will be able to access GIAC exam and both mock test 7 days after your course/training has concluded
- You will have 4 months to take the exam and 161 days to complete practice tests.
- You will have access to all the course recordings and materials for 4 months, so that you can prepare for the exam.
- If you feel 4 months is not enough you can purchase 45 days extension for $459
- This option will become available in you account 15 days before your current deadline
- Your course and all the courseware will be extended alongside the exam.
- You can purchase up to 10 extensions.


Certification Study Help
Better GIAC Testing with Pancakes - https://tisiphone.net/2015/08/18/giac-testing/
Matthew Toussain - Get Certified! All You Need to Know to Rock GIAC Exams - https://www.youtube.com/watch?v=jYQ88CYGS8s
Matthew Toussain - Wargaming GIAC Certifications - https://www.opensecurity.io/blog/wargaming-giac-certifications
Matthew Toussain - Rocking the GIAC Exam with Voltaire - https://www.youtube.com/watch?v=bHpkTArlXWc&t=93s
Matthew Toussain - Voltaire (Index building App) - https://voltaire.publickey.io/
Anki Powerfil Flash Cards - https://apps.ankiweb.net/
Develop Technical Recall Skills: Spaced Repetition with Anki - https://www.youtube.com/watch?v=kfJjtztHFrE
Ron Hamann -Are You Certifiable? | SANS@MIC Talk - https://www.youtube.com/watch?v=vHTGJJZ0UcQ&t=3s
https://www.youtube.com/watch?v=v-FBLbhv4aI


# Day 1

## Static Analysis
- Process
    1. Review strings with `floss` or `pestr {mal.exe} | egrep  '^[-0-9a-zA-Z.+/ ();=\\]+$'`
    2. Review structure with `pestudio` (Win) and `peframe` (Lin) and `detectiteasy` (both)
        - Identify if it is 64 or 32 for later.

### Review Strings
- The goal is to be looking for import information, windows APIs or other details that can indicate the nature of the malware.
```bash
# Floss.
floss {mal.exe} 

#PEstr with REGEX to clean view
pestr {mal.exe} | egrep  '^[-0-9a-zA-Z.+/ ();=\\]+$'
```

### Review structure of PE
- Look at headers and imports and check to see any anomolies.
```bash
# PEStudio
    ## GUI based and easy to click through. Sort by blacklist to see interesting APIs or strings.
    ## Note: Reckoning in the imports section is a typo for Recon.
"Drag and drop the exe into the PEStudio window"

# PEFrame
    ## Takes a minute or so to run depending on size. XLM Error is expected. Shows behavior and possible investigation tools. Also has an import table hash.
    ## Beware of false positives, but dig into the possibility.
peframe {mal.exe}

#Detect it easy
    ## Shows you how the exe was compiled and other useful buttons with similar functionality to other tools in the course.
"Open gui and load exe into the tool"
```

## Dynamic Analysis
- Process
    1. **Launch** `Process Hacker` and `Process Monitor` on Windows REM Workstation. 
        - **Turn off capture** on `Process Monitor` momentarily.
    2. Launch `Regshot` and **take the first snapshot** using this tool on Windows REM Workstation.
    3. Launch `Wireshark` on REMnux and start its capture.
    4. Activate monitoring in `Process Monitor`\
    **!! Infect Windows REM Workstation with brbbot.exe. (You want the malware to have admin rights to let it have full potential).**
    5. **Terminate** the brbbot.exe process and stop capture in `Process Monitor`.
    6. **Stop capture** in `Wireshark`.
    7. **Take the second** `Regshot` **snapshot** and **compare** it to the first one, examining Regshot's report.
        - Go to some of the locations created and review what was made with other tools.
    8. **Analyze** Process Monitor's log file using `ProcDOT`.
        - Focus on the things that are orange or red.
    9. **Examine** `Wireshark's` log file.
        1. Look at DNS
        2. Look at HTTP (HTTPS is encrypted and likely unhelpful)
        3. Depending on sample look at SMB
        4. Do basic wiresharking to review protocols, conversations, etc.

- Process to Modify Lab for Network Analysis. 
    - We us resource starvation to see how the malware responds, maybe it tries different DNS servers
    1. Launch `fakedns` on REMnux and confirm that it is working.
    2. Start a new capture in `Wireshark` on REMnux, and then reinfect Windows REM Workstation with brbbot.exe.
    3. Terminate brbbot.exe and stop capture in Wireshark, and then examine the log.
    4. Start the web server on REMnux `httpd start`, activate capture in Wireshark, and then reinfect Windows REM Workstation with brbbot.exe.
    5. Terminate brbbot.exe and stop capture in Wireshark, and then examine the log.
    6. Save the encoded payload from the HTTP traffic for later analysis.

### Emulation
- This is a step between disassembly and debugging. Uses specialized tools to preview the key actions the specimen will take when it runs.
- Emulators work regardless of the OS.
- Use the review of the emulator to inform your debugging.
- Emulators have a hard time with packed samples.

```bash
# Speakeasy
speakeasy -t brbbot.exe -o brbbot.json &> brbbot.txt #The redirect is for the redirection of all output of the command while its running

    # To review speak easy use jq
    # jq is a tool for processing JSON inputs, applying the given filter to its JSON text inputs and producing the filter's results as JSON on standard output.
        jq -r '.. | select(.api_name?)' brbbot.json #.. is all json objects. select is a select statement and the question mark
```
==CAPA==
```bash 
capa mal.exe # Provides a quick overview and matching numbers to the MITRE or MBC frameworks.
capa -vv mal.exe # Provides verbose details with where in memory the event was called.
```

### Debugging
- Case of command doesn't matter, but case of function does.
- We don't want to step into windows API and debug that, we want to debug user code.
- Debuggers load information into the application so you can view what is happening at certain points, like the details of a command before it is encrypted.

```bash
# x32/64 dbg
    ##Set breakpoints on certain functions by typing in the command bar at the bottom of x32/64 dbg

bp {FunctionName}
    ## You can find the handle (known from looking at the documentation) by going to handles at the top and refreshing.
    ## Under debug, click run to user code.
    ## You can also select a line and then run to selection.
    ## Debug by running to the line after the instruction you're interested in.

# API Monitor
    ## Must close debugger to load file
    ## API monitor is faster than a debugger at times.
"Open api monitor and select new process"
```

### Intercepting HTTPS traffic

- INETSim receives HTTPS traffic where wireshark will not. Simply run it on the remnux machine then review the logs at `sudo vim /var/log/inetsim/service.log`
- Alternatively you can launch fiddler on your windows machine and run the exe.
- To deal with hard coded IP address redirects you must adjust IP tables.
    - On regular linux `iptables -t nat -A PREROUTING -i eth0 -j REDIRECT`
    - on remnux `httpd start` then `accept-all-ips start`
    - Alternatively, fiddler makes this a lot easier.

# Day 2
- word = 2 bytes (16)
- dword = 4 bytes (32)
- qword = 8 bytes (64)

`ghidra` is useful over IDA because you get the decompiler for free. `binary ninja` has better scripting capability, but it costs funds.

- Ghidra is a robust database manager.

## Ghidra

1. Open ghidra
2. Click File > New Project > Non-shared.
3. Load the file > and click okay.
4. Double click the file and analyze > select windows PE at the bottom.
5. As you analyze your goal is to make the changes more understable as you go through it so you aren't looking at heximal decimal values.

- Multiple monitors for different windows open. Preferred are:
    - Symbol reference
    - Function Call Tree
    - Defined Strings

### Analysis
- You do not want to start reviewing at entry, because that is added by decompiler.
- Click window > `symbol references`
    - This lets you find functions and search.
        - "registry"
        - "file"
        - "process"
        - Prococol names: "http", "dns", "p2p", "irc"
- Click window > `function graph`
    - This lets you view the code as its logical flow graphically.
- Windows API notes.
    - 'w' means 16 bits
    - 'a' means ansi
    - Ignore the data access portion of the windows api as that is just where it is stored. 
        - Look to call instead. If you click the subroutine it jumps to the function
        - Click on the from location rather than subroutine location.
    - You have to dig into google or SDK to figure out what the values added mean. Pair the values you find in the source code with the details of the documentation from microsoft. Sadly you can't use both.
        - https://github.com/tpn/winsdk-10/blob/master/Include/10.0.14393.0/um/WinInet.h
        - https://malapi.io/

```bash
      004047da     PUSH     EAX                                             ; PHKEY phkResult for RegOpenKeyExA
      004047db     PUSH     0x2000000                                       ; REGSAM samDesired for RegOpenKeyExA
      004047e0     PUSH     0x0                                             ; DWORD ulOptions for RegOpenKeyExA
      004047e2     PUSH     s_Software\Microsoft\Windows\Curre_00413c70     ; LPCSTR lpSubKey for RegOpenKeyExA
      004047e7     PUSH     0x80000001                                      ; HKEY hKey for RegOpenKeyExA
      004047ec     MOV      byte ptr [EBP + -0x4], 0x16
      004047f0     CALL     dword ptr [->ADVAPI32.DLL::RegOpenKeyExA]       ; = 00016e0e
```
- Parameters are numbered per the documentation going up as they are viewed in the stack
    - in the example above, hkey is the first parameter.
    - subtract 4 from ebp subtracts 4 bytes from EBP

> Managing Readability Tip
> ***
> Because data loaded in could be representative of anything, its your responsibility to determine the context of what is meant.
> If you right click a value like the hkey and select `set equate`. This lets you redefine what the value looks like in ghidra so its easier to read as you go. It will replace that value with human readable string throughout its location in the code.

> Managing Readability Tip 2
> ***
> If an API doesn't have helpful EOL comments loaded you can add them.
> 1. Go to the "Data Type Manager" on the left window and find the library for which your APIs are called.
> 2. Right click API (ex. winapi_32) > select "Apply Function Data Types"
> 3. Click Analysis at the top of the window > Hover over one shot > Click "WindowsPE x86 Propogate External Parameters".

- Comments
    - Type `;` after the instruction to do an EOL comment.

> Managing Readability Tip 3: Making Local Variables readble.
> ***
> When you have local variables you can adjust what they mean.
> 1. Look at comments provided by ghidra.
> 2. Go to the header of the function, highlight the local_variable > press "T" to choose data type > start typing what was listed in the comment without lp.
> 3. Apply and ignore warning.
> 4. Relable the variable something meaningful.

### Assembly
- You can ignore the "byte ptr" or "dword ptr".
- Registers
    - EAX: Used for addition, multiplication, return. 
        - Because EAX is a return register, after an api is called, the return value is stored in EAX
    - ECX: Used as counter
    - EBP: Used to reference arguments and local variables (base point)
    - ESP: Points to last item on stack
    - ESI/EDI: Moving things into memory source/destination.
    - EIP: Instruction pointer
    - EFLAGS: zero, carry, comp
    - Segment regisers: Used for 16 bit code
        - CS: Code segment
        - DS: Data segment
        - SS: Stack segment
- Ghidra uses strings in code as its ptr value. Its a layer of abstraction. The `s_Software\Microsoft..._00413c70 ` above is a pointer with the last 8 characters referring to the 32 bit location. When you click it, you will see that location in memory.
- Brackets mean fetch data at the specified address into the location. Without brackets mean load the value into. Brackets are similar to pointers discusses above.
- Reading stack variables
    - Local_8 is base point + 8 bytes
    - Local_c is base point + 12 bytes (its hex you idiot)

- Params are arguments
- local are local variables.

```bash
    004047ec     MOV      EAX, [0x004047f0]  #Loads 0x80 into EAX
    004047f0     0x80

    004047ec     MOV      EAX, 0x004047f0  #Loads 0x004047f0 into EAX
    004047f0     0x80

    00406129     LEA     EAX=>local_54, [EBP + -0x50] #Takes EBP minus 0x50 which is the local_54 value and puts it in EAX
                                                      #EAX=>Variable is just a comment in ghidra helping you know EAX is.

```
- Comparisons and jumps
    - Page 41 of the book does a good job explaining.
    - http://unixwiz.net/techtips/x86-jumps.html 
        - If you see the same code in one box, that means they mean the same thing.
    - TEST EAX, EAX. As the return value of the function, it will let you know if after returning from the API functions it will be zero or not zero. Review windows API documentation to understand what is happening.
    - XOR a value with itself will set it to zero.
    - TEST will do an and of the value to itself and is used to set the zero flag without changing the register.
    - Within the function graph
        - Arrows up are loops.
        - Green arrows mean it does jump, red means it doesn't jump. Not that its true or false.

### Connecting out for C2 traffic
- create an http connection with InternetOpen and InternetConnect
- build an HTTP request with HttpOpenRequest
- send and http request with HttpSendRequest
- read response with InternetReadFile

- LPCSTRING is a cstring, an array of characters with a null terminator.
    - Click a data value and hit `c` on the keyboard to "clear" the data that ghidra already has loaded.
    - Right click the first hex value > hover over data > click "strings"
    - Then changed the label name to something more helpful related to what you decoded.
- CWSTRING or data with zeros in between use "terminated unicode"

### Obfuscating with resources
- Authors are trying to hide things when they find a resource then write to a file. Find resource > load resource > lock it > define pointer > write it to file.
- An alternative to having an IAT entry is to use LoadLibraryA to keep us from knowing they're using it.
    - LoadResource and GetProcAddress allows you to use a value from the library without the table.
- In `pestudio` you can view the resources and see the ASDASD file. You can right click to dump the file and review.
- Set breakpoints on `getprocaddress` and `loadlibrary`

- set a breakpoint on `CreateProcessInternalW` all function will flow to that.
    - https://a-twisted-world.blogspot.com/2008/03/createprocessinternal-function.html

# Day 3

## PDFs

- Details about PDFs go here

**Initial Analysis**
```bash
pdfid.py file.pdf
```
