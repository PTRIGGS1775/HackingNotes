# FOR610

This page is designed to keep track of all relevant commands and tools during the FOR610 course. This is organized by course days but will be sorted by task details later.

- Use your lab to examine the network traffic and packet. Then use a connected machine in the cloud, perhaps a tails instance to pull the malware. To take it a step further you could purchase the space with gift cards.
- Malware bazaar is a place to look at malware samples or github malware repo (the zoo) or vx underground or [malware-traffic-analysis](https://www.malware-traffic-analysis.net/).

### Practice: Sources for more malware samples:
    - https://github.com/ytisf/theZoo
    - https://bazaar.abuse.ch/
    - https://vx-underground.org/ (also has analysis reports)
    - https://www.malware-traffic-analysis.net/ 
    - https://malpedia.caad.fkie.fraunhofer.de/

## Resources to get better
https://forum.tuts4you.com/forum/106-malware-reverse-engineering/
https://vk-intel.org/ (download all from https://www.dropbox.com/scl/fi/ia9ldxn9cf1j1l8bo72jy/Reverse-Engineering-Malware-Deep-Insight-VK_Intel_-Vitali-Kremez.pdf?rlkey=pg0onr9ghzweipmvoai6gym8a&st=fq4jhkp7&dl=0)
https://courses.zero2auto.com/ (Good courses about 200 bucks)
https://www.0ffset.net/blog/
https://medium.com/@jason.reaves
https://www.youtube.com/@OALABS/videos
https://start.me/p/jj2KwQ/malware-analysis?locale=en
https://otx.alienvault.com/browse/global/pulses
https://www.team-cymru.com/community-news-and-events
https://www.unpac.me/ Unpacker
https://github.com/LordNoteworthy/al-khaser/tree/master/al-khaser Anti Analysis code to understand.
https://www.sans.org/blog/how-you-can-start-learning-malware-analysis/

## Certification tips
- https://www.giac.org/certifications/reverse-engineering-malware-grem/
- You will be asked to apply your knowledge.
- Do your labs multiple times.
- Create a good index
- You'll get two practice tests. Get yourself ready first before taking practice tests.
- APIs should be in your index

FYI, Exam Takers
- You will be able to access GIAC exam and both mock test 7 days after your course/training has concluded
- You will have 4 months to take the exam and 161 days to complete practice tests.
- You will have access to all the course recordings and materials for 4 months, so that you can prepare for the exam.
- If you feel 4 months is not enough you can purchase 45 days extension for $459
- This option will become available in you account 15 days before your current deadline
- Your course and all the courseware will be extended alongside the exam.
- You can purchase up to 10 extensions.


Certification Study Help
Better GIAC Testing with Pancakes - https://tisiphone.net/2015/08/18/giac-testing/
Matthew Toussain - Get Certified! All You Need to Know to Rock GIAC Exams - https://www.youtube.com/watch?v=jYQ88CYGS8s
Matthew Toussain - Wargaming GIAC Certifications - https://www.opensecurity.io/blog/wargaming-giac-certifications
Matthew Toussain - Rocking the GIAC Exam with Voltaire - https://www.youtube.com/watch?v=bHpkTArlXWc&t=93s
Matthew Toussain - Voltaire (Index building App) - https://voltaire.publickey.io/
Anki Powerfil Flash Cards - https://apps.ankiweb.net/
Develop Technical Recall Skills: Spaced Repetition with Anki - https://www.youtube.com/watch?v=kfJjtztHFrE
Ron Hamann -Are You Certifiable? | SANS@MIC Talk - https://www.youtube.com/watch?v=vHTGJJZ0UcQ&t=3s
https://www.youtube.com/watch?v=v-FBLbhv4aI

Day 6 Hints
- Process moved into ESI is called later in a function CALL ESI. Its only called in the call not the MOV
- Do a complete scan of the code when deobfuscating stack strings. Other string values may be listed elsewhere.
- If something is compressed they are probaly trying to hide something from you. Investigate API calls to this.
- Follow things in dump to view decompressed data.
- You may see a call EDI need to figure out what EDI is doing, this was referenced during exercise b5p48
- Functions may not be obvious b5p70
- Save trivia for the end
- Disable ASLR as part of your first step before debugging
    - set scylla hide
    - disable exceptions
- If your dumped malware from dbg doesn't run, it may need to decode further.

# Day 1

## Static Analysis
- Process
    1. Review strings with `floss` or `pestr {mal.exe} | egrep  '^[-0-9a-zA-Z.+/ ();=\\]+$'`
    2. Review structure with `pestudio` (Win) and `peframe` (Lin) and `detectiteasy` (both)
        - Identify if it is 64 or 32 for later.

### Review Strings
- The goal is to be looking for import information, windows APIs or other details that can indicate the nature of the malware.
```bash
# Floss.
floss mal.exe
```
```bash
#PEstr with REGEX to clean view
pestr mal.exe | egrep  '^[-0-9a-zA-Z.+/ ();=\\]+$'
```

### Review structure of PE
- Look at headers and imports and check to see any anomolies.
```bash
# PEStudio
    ## GUI based and easy to click through. Sort by blacklist to see interesting APIs or strings.
    ## Note: Reckoning in the imports section is a typo for Recon.
"Drag and drop the exe into the PEStudio window"

# PEFrame
    ## Takes a minute or so to run depending on size. XLM Error is expected. Shows behavior and possible investigation tools. Also has an import table hash.
    ## Beware of false positives, but dig into the possibility.
peframe {mal.exe}

#Detect it easy
    ## Shows you how the exe was compiled and other useful buttons with similar functionality to other tools in the course.
"Open gui and load exe into the tool"
```

## Dynamic Analysis
- Process
    1. **Launch** `Process Hacker` and `Process Monitor` on Windows REM Workstation. 
        - **Turn off capture** on `Process Monitor` momentarily.
    2. Launch `Regshot` and **take the first snapshot** using this tool on Windows REM Workstation.
    3. Launch `Wireshark` on REMnux and start its capture.
    4. Activate monitoring in `Process Monitor`\
    **!! Infect Windows REM Workstation with brbbot.exe. (You want the malware to have admin rights to let it have full potential).**
    5. **Terminate** the brbbot.exe process and stop capture in `Process Monitor`.
    6. **Stop capture** in `Wireshark`.
    7. **Take the second** `Regshot` **snapshot** and **compare** it to the first one, examining Regshot's report.
        - Go to some of the locations created and review what was made with other tools.
    8. **Analyze** Process Monitor's log file using `ProcDOT`.
        - Focus on the things that are orange or red.
    9. **Examine** `Wireshark's` log file.
        1. Look at DNS
        2. Look at HTTP (HTTPS is encrypted and likely unhelpful)
        3. Depending on sample look at SMB
        4. Do basic wiresharking to review protocols, conversations, etc.

- Process to Modify Lab for Network Analysis. 
    - We us resource starvation to see how the malware responds, maybe it tries different DNS servers
    1. Launch `fakedns` on REMnux and confirm that it is working.
    2. Start a new capture in `Wireshark` on REMnux, and then reinfect Windows REM Workstation with brbbot.exe.
    3. Terminate brbbot.exe and stop capture in Wireshark, and then examine the log.
    4. Start the web server on REMnux `httpd start`, activate capture in Wireshark, and then reinfect Windows REM Workstation with brbbot.exe.
    5. Terminate brbbot.exe and stop capture in Wireshark, and then examine the log.
    6. Save the encoded payload from the HTTP traffic for later analysis.

### Emulation
- This is a step between disassembly and debugging. Uses specialized tools to preview the key actions the specimen will take when it runs.
- Emulators work regardless of the OS.
- Use the review of the emulator to inform your debugging.
- Emulators have a hard time with packed samples.

**Speakeasy**
```bash
speakeasy -t brbbot.exe -o brbbot.json &> brbbot.txt #The redirect is for the redirection of all output of the command while its running

    # To review speak easy use jq
    # jq is a tool for processing JSON inputs, applying the given filter to its JSON text inputs and producing the filter's results as JSON on standard output.
        jq -r '.. | select(.api_name?)' brbbot.json #.. is all json objects. select is a select statement and the question mark
```
**CAPA**
```bash 
# Provides a quick overview and matching numbers to the MITRE or MBC frameworks.
capa mal.exe
```
```bash
# Provides verbose details with where in memory the event was called.
# You can search within less with a forward slash
capa -vv mal.exe | less     
```

### Debugging
- Case of command doesn't matter, but case of function does.
- We don't want to step into windows API and debug that, we want to debug user code.
- Debuggers load information into the application so you can view what is happening at certain points, like the details of a command before it is encrypted.

```bash
# x32/64 dbg
    ##Set breakpoints on certain functions by typing in the command bar at the bottom of x32/64 dbg

bp {FunctionName}
    ## You can find the handle (known from looking at the documentation) by going to handles at the top and refreshing.
    ## Under debug, click run to user code.
    ## You can also select a line and then run to selection.
    ## Debug by running to the line after the instruction you're interested in.

# API Monitor
    ## Must close debugger to load file
    ## API monitor is faster than a debugger at times.
"Open api monitor and select new process"
```

### Intercepting HTTPS traffic

- INETSim receives HTTPS traffic where wireshark will not. Simply run it on the remnux machine then review the logs at 
    ```bash
    sudo vim /var/log/inetsim/service.log
    ```
- Alternatively you can launch fiddler on your windows machine and run the exe.
- To deal with hard coded IP address redirects you must adjust IP tables.
    - On regular linux 
        ```bash
        iptables -t nat -A PREROUTING -i eth0 -j REDIRECT
        ```
    - on remnux `httpd start` then `accept-all-ips start`
    - Alternatively, fiddler makes this a lot easier.

# Day 2
- word = 2 bytes (16)
- dword = 4 bytes (32)
- qword = 8 bytes (64)

`ghidra` is useful over IDA because you get the decompiler for free. `binary ninja` has better scripting capability, but it costs funds.

- Ghidra is a robust database manager.

## Ghidra

1. Open ghidra
2. Click File > New Project > Non-shared.
3. Load the file > and click okay.
4. Double click the file and analyze > select windows PE at the bottom.
5. As you analyze your goal is to make the changes more understable as you go through it so you aren't looking at heximal decimal values.

- Multiple monitors for different windows open. Preferred are:
    - Symbol reference
    - Function Call Tree
    - Defined Strings

### Analysis
- You do not want to start reviewing at entry, because that is added by decompiler.
- Click window > `symbol references`
    - This lets you find functions and search.
        - "registry"
        - "file"
        - "process"
        - Prococol names: "http", "dns", "p2p", "irc"
- Click window > `function graph`
    - This lets you view the code as its logical flow graphically.
- Windows API notes.
    - 'w' means 16 bits
    - 'a' means ansi
    - Ignore the data access portion of the windows api as that is just where it is stored. 
        - Look to call instead. If you click the subroutine it jumps to the function
        - Click on the from location rather than subroutine location.
    - You have to dig into google or SDK to figure out what the values added mean. Pair the values you find in the source code with the details of the documentation from microsoft. Sadly you can't use both.
        - https://github.com/tpn/winsdk-10/blob/master/Include/10.0.14393.0/um/WinInet.h
        - https://malapi.io/

```bash
      004047da     PUSH     EAX                                             ; PHKEY phkResult for RegOpenKeyExA
      004047db     PUSH     0x2000000                                       ; REGSAM samDesired for RegOpenKeyExA
      004047e0     PUSH     0x0                                             ; DWORD ulOptions for RegOpenKeyExA
      004047e2     PUSH     s_Software\Microsoft\Windows\Curre_00413c70     ; LPCSTR lpSubKey for RegOpenKeyExA
      004047e7     PUSH     0x80000001                                      ; HKEY hKey for RegOpenKeyExA
      004047ec     MOV      byte ptr [EBP + -0x4], 0x16
      004047f0     CALL     dword ptr [->ADVAPI32.DLL::RegOpenKeyExA]       ; = 00016e0e
```
- Parameters are numbered per the documentation going up as they are viewed in the stack
    - in the example above, hkey is the first parameter.
    - subtract 4 from ebp subtracts 4 bytes from EBP

> Managing Readability Tip
> ***
> Because data loaded in could be representative of anything, its your responsibility to determine the context of what is meant.
> If you right click a value like the hkey and select `set equate`. This lets you redefine what the value looks like in ghidra so its easier to read as you go. It will replace that value with human readable string throughout its location in the code.

> Managing Readability Tip 2
> ***
> If an API doesn't have helpful EOL comments loaded you can add them.
> 1. Go to the "Data Type Manager" on the left window and find the library for which your APIs are called.
> 2. Right click API (ex. winapi_32) > select "Apply Function Data Types"
> 3. Click Analysis at the top of the window > Hover over one shot > Click "WindowsPE x86 Propogate External Parameters".

- Comments
    - Type `;` after the instruction to do an EOL comment.

> Managing Readability Tip 3: Making Local Variables readble.
> ***
> When you have local variables you can adjust what they mean.
> 1. Look at comments provided by ghidra.
> 2. Go to the header of the function, highlight the local_variable > press "T" to choose data type > start typing what was listed in the comment without lp.
> 3. Apply and ignore warning.
> 4. Relable the variable something meaningful.

### Assembly
- You can ignore the "byte ptr" or "dword ptr".
- Registers
    - EAX: Used for addition, multiplication, return. 
        - Because EAX is a return register, after an api is called, the return value is stored in EAX
    - ECX: Used as counter
    - EBP: Used to reference arguments and local variables (base point)
    - ESP: Points to last item on stack
    - ESI/EDI: Moving things into memory source/destination.
    - EIP: Instruction pointer
    - EFLAGS: zero, carry, comp
    - Segment regisers: Used for 16 bit code
        - CS: Code segment
        - DS: Data segment
        - SS: Stack segment
- Ghidra uses strings in code as its ptr value. Its a layer of abstraction. The `s_Software\Microsoft..._00413c70 ` above is a pointer with the last 8 characters referring to the 32 bit location. When you click it, you will see that location in memory.
- Brackets mean fetch data at the specified address into the location. Without brackets mean load the value into. Brackets are similar to pointers discusses above.
- Reading stack variables
    - Local_8 is base point + 8 bytes
    - Local_c is base point + 12 bytes (its hex you idiot)
- POP REGISTER, puts the top of the stack into that register.
- Params are arguments
- local are local variables.

```bash
    004047ec     MOV      EAX, [0x004047f0]  #Loads 0x80 into EAX
    004047f0     0x80

    004047ec     MOV      EAX, 0x004047f0  #Loads 0x004047f0 into EAX
    004047f0     0x80

    00406129     LEA     EAX=>local_54, [EBP + -0x50] #Takes EBP minus 0x50 which is the local_54 value and puts it in EAX
                                                      #EAX=>Variable is just a comment in ghidra helping you know EAX is.

```
- Comparisons and jumps
    - Page 41 of the book does a good job explaining.
    - http://unixwiz.net/techtips/x86-jumps.html 
        - If you see the same code in one box, that means they mean the same thing.
    - TEST EAX, EAX. As the return value of the function, it will let you know if after returning from the API functions it will be zero or not zero. Review windows API documentation to understand what is happening.
    - XOR a value with itself will set it to zero.
    - TEST will do an and of the value to itself and is used to set the zero flag without changing the register.
    - Within the function graph
        - Arrows up are loops.
        - Green arrows mean it does jump, red means it doesn't jump. Not that its true or false.

### Connecting out for C2 traffic
- create an http connection with InternetOpen and InternetConnect
- build an HTTP request with HttpOpenRequest
- send and http request with HttpSendRequest
- read response with InternetReadFile

- LPCSTRING is a cstring, an array of characters with a null terminator.
    - Click a data value and hit `c` on the keyboard to "clear" the data that ghidra already has loaded.
    - Right click the first hex value > hover over data > click "strings"
    - Then changed the label name to something more helpful related to what you decoded.
- CWSTRING or data with zeros in between use "terminated unicode"

### Obfuscating with resources
- Authors are trying to hide things when they find a resource then write to a file. Find resource > load resource > lock it > define pointer > write it to file.
- An alternative to having an IAT entry is to use LoadLibraryA to keep us from knowing they're using it.
    - LoadResource and GetProcAddress allows you to use a value from the library without the table.
- In `pestudio` you can view the resources and see the ASDASD file. You can right click to dump the file and review.
- Set breakpoints on `getprocaddress` and `loadlibrary`

- set a breakpoint on `CreateProcessInternalW` all function will flow to that.
    - https://a-twisted-world.blogspot.com/2008/03/createprocessinternal-function.html

# Day 3
- When investigating malicious links you can use:
    - `wget/curl`, `Pinpoint/Scout`, honeypot like `thug`, or a real browser on a vulnerable system.
- You can export files from Fiddler and follow the same format.
- With didier tools, you can play alot with the format of the output with appropriate switches.

## PDFs
- More details: https://blog.didierstevens.com/programs/pdf-tools/
- More details: https://blog.didierstevens.com/2008/04/09/quickpost-about-the-physical-and-logical-structure-of-pdf-files/
- Risky Keywords
    - Execute embedded JavaScript: /JS, /JavaScript, /AcroForm, /XFA
    - Try launching external or embedded programs: /Launch, /EmbeddedFiles
    - Take action automatically when the PDF file is opened: /OpenAction, /AA
    - Interact with websites: /URI, /SubmitForm

- The object on the left side of this slide has the object number 1 and the generation number 0. The object's definition
starts with obj and ends with endobj keywords. On this slide, object 1 0 directs the PDF application to take
automatic action (/AA) when it opens (/O) the document. This object refers to object 43 0 by specifying that object's identifier followed by the keyword **R**.

```
1 0 obj
Type: /Page
<<
    /AA /O 43 0 R
>>
endobj
```
- PDF objects use streams to store data, such as text, font definitions, and pictures as a sequence of bytes. Malicious
PDFs sometimes conceal JavaScript inside streams. As shown on the right side of this slide in object 44 0, the bytes
that represent the stream are delineated by keywords stream and endstream. Stream contents are usually stored
in an encoded form. They can be decoded by applying one or more "filters," or algorithms designated as part of the
object.

**PDFID.py: Initial Recon**
```bash
#Scans for suspicious keywords without formally parsing.
pdfid.py file.pdf 
```
```bash
#-n looks at only files present in the document.
pdfid.py file.pdf -n
```
**PDF-PARSER: More detailed review**
- Follow objects until you find additional details and associated objects to malicious actions.
- Focus on looking for annotations to links. Walk through with "-r" (to find the paRent of an object) and look at files with "-o" (to go dOwn the tree).
- If you find an objext stream. You'll need to preface all of your usual commands with "-O".
- For dealing with passwords/encryption look at b3.p35

```bash
#Parses the PDF file and can locate specific objects and display their contents.
pdf-parser.py file.pdf
```
```bash
#-a shows statistics
pdf-parser.py file.pdf -a
```
```bash
#-s shows searches file for objects that include specific keywords.
#Reference keywords from /{word} seen in statistics or initial analysis.
pdf-parser.py file.pdf -s /word
```
```bash
#-k to extract all clickable links.
#Reference keywords from /{word} seen in statistics or initial analysis.
pdf-parser.py file.pdf -k /word
```
```bash
#-o to view objects and -d to dump to a file name.
#Reference the decode value to know what the file format is.
pdf-parser.py file.pdf -o num -d file.ext
```
```bash
#-r shows references to your object
pdf-parser.py file.pdf -r ObjNum
```
```bash
#-O -a directs parser to look into object streams. Use if you see /ObjStm
pdf-parser.py file.pdf -r ObjNum
```

## VBA Macros/Working with Open XML(OOXML)
- OOXML are generally zip archives that include document's components as individual files within the zip archive.
- While you could extract them you could use other tools as well.
- CDFV2 is another name for OLE2 which are both OOXML files
- Operate the same as other programs with access to the kernel.
- Install word in virtual boxes.

**Recon: Documents**
```bash
# Tells you what type of file this is.
trid file.doc
```

**zipdump.py/exiftool: Recon**
```bash
# Review metadata
exiftool file.doc
```
```bash
# Review components of OOXML document. 
zipdump.py file.doc
```
```bash
# You can extract specific files with -s and the index number and -d to dump
# The dump will pull the data so you need to redirect to a file. Reference the name and type from previous command.
zimpdump.py file.doc -s Num -d > Output.Ext
```
- To clean up the output of XML files use 
    ```bash
    zipdump.py file.doc -s Num -d | xmldump.py pretty
    ```

**olevba: get code**
- You could open the file to view macros or use tools to view instead.
```bash
# Olevba locates, decodes and extracts VBA macros with a list of risky code.
olevba file.doc > file.olevba
```

**oledump.py: detailed analysis**
```bash
# oledump.py shows structure of the file with details. -i provide extra info.
oledump.py file.doc -i
```
```bash
# If the code from oledump is split across streams. -s selects individual streams but passing "a" will put them all together. 
#-v decompresses it, the -i above showed us compressed with #+# values and grep "^'" cleans up the code without comments.
# Review dump file in VScode and clean up. 1) Delete any attributes. 2) replace variables with actual values.
oledump.py file.doc -s a -v | grep -v "^'" > file.vbs
```

> TIP: Conversions for OLE DUMP
> ***
> -A will show only ascii
>
> -S will show strings
>
> - Add the following lines to remove http strings in arrays. You may need to play with this for different files.
>    ```bash
>    | grep "^array"             #Extract lines that start with "array"
>    | re-search.py -n str-u     #Extract strings within quotes
>    | sets.py join ""           #Join the lines into a single line
>    | sed "s/====//g"           #Remove "====" separators
>    ```

- Convert char(#) to strings with numbers-to-string.py and use -j to join.
    ```bash
    numbers-to-string.py -j
    ```
- Convert base64 in string. PowerShell encodedcommand does so in base64. More details b3p69-71
    - More details: https://gist.github.com/edygert
    ```bash
    # First pipe the command to just base64dump.py to find the id. Then use that as your index value.
    oledump.py file.doc -s OleIndex -d | base64dump.py -s b64Index -a
    # Once you identify additionaly encoding use -t to change.
    ```

```bash
#-S will show you strings to clean up hex if not decompressing.
oledump.py file.doc -s index -S
```

**ViperMonkey: emulation and deobfuscation**
```bash
# Runs and deobfuscates the code
vmonkey file.doc > file.vmonkey
```

**evilclippy: remove password**
```bash
# Use this so you can view in word or a debugger
evilclippy -uu
```

**scdbgc: read/debug shellcode**
```bash
# More details on b3p75
scdbgc /f file.bin /s -l
```

## Rich Text Format (RTF)
- RTF uses curly braces {} to create groups.
- Remainders exist outside of the braces.
- backslashes \ are used to signify commands
- Process
    - Look for embedded objects and anomylous artifcats
    - Locate, extract, and run shellcode

```bash
# See objects inside. Note if the same value is mentioned it likely refers to nested objects
# Look for anomolies in the pattern for anything that stands out and invesitgate further
rtfdump.py file.doc
```
```bash
# To extract objects use -O to list only objects, and the standard select rules.
rtfdump.py file.doc -O -s Index -d > file.object
```
- At this point you can start using `oledump` to continue with the regular process.
- Interesting files are to look at large files.

```bash
# Determine what potential shellcode is saying. -d 3 disables rot transofrmation to avoid false positives.
xorsearch -W -d 3 file.bin
```

## Deobfuscating JavaScript
- Outside of the browser JS can access system resources.
- You'll need to do dynamic analysis.
- JS on remnux is also referred to as SpiderMonkey
- JS must have an eval statement if it wants to run obfuscated

**js-beautify: deobfuscate**
```bash
js-beautify file.js > NewFile.js
```
```bash
# Run the command without issues
js -f /usr/share/remnux/objects.js -f file.js
```

# Day 4

## Recognizing Packed Malware
- Much like the JS code, packed malware decodes the code into memory when it runs. Safeguarding it from static analysis.
- You don't know the entry point of the actual code, only the unpacker. You need to find the malware entry point.
    - Think of packed malware as 2 programs. Non-malicious unpacker that loads the malware, then the unpacked malware runing.

- Use `pestudio` and `detectiteasy`/`exeinfo` to review if malware is packed. You can also use `diec` on remnux.
- You can also use `bytehist` to look at entropy.
- Note a program in memory looks different than it does on disk. NEED THAT ENTRY POINT.
    > Tip
    >***
    > You can view the entryp point in `pestudio` under optional-header.

## Basic Unpacking
- You could use a hex editor to change heading names like NPX to UPX

**Confirm that you can view the unpacked program in memory**
- Before you can unpack disable ASLR.
    - Load exe in CFFExplore > click optional header > click "Click here" next to DllCHaracteristics > Turn off "DLL can move"
    - Save and overwrite original file.
    - Alternatively you can use the command `setdllcharacteristics -d file.exe`

- Easiest way to know something is unpacked is to run it.
    - Run the exe and look at it in process hacker > Double Clcik exe > click memory tab > click strings.

**Get a usable file for static: Dump the file out of memory onto disk**
- Using `scylla` choose the currently running process. Click Dump.
    - Then you need to fix the dump: 1. Click IAT AutoSearch > 2. Get imports > 3. fix dump
    > NOTE:
    > ***
    > You don't know the original entry point yet so you need to fix that.

**Use a debugger for dumping**
- Using `x64dbg`
    - Make sure you've disabled ASLR.
    - Debugger automatically starts at the entry point of the unpacker while its running.
    1. Scroll down until you see code that looks completely different. Set your breakpoint at the JMP instruction before the code changes. YOU WONT ALWAYS BE ABLE TO FIND IT SO EASILY
    2. Step into the program
    > NOTE
    > ***
    > Step into "Steps into call" and step over "steps over call"

    - You can confirm you're in the right spot by right clicking in the debugger and searching for strings in the region.
    3. CLick plugins at the top > `OllyDumpEx` > Click "GetRIP as OEP"
    4. For UPX: Next Double click UPX1 and select MEM_WRITE then click okay.
        - Parts of the code were written into the unpacker and we need to make sure its able to write there when it runs.
    - Once dumped you need to fix the import address table.
    5. Click plugins at the top > `Scylla` > Click "IAT Autosearch" > "get Imports" > fix the dump you just made in step 4.
        - Click no if you get asked "do you want to use advanced search"

**What to do if you can't find the OEP**
- One approach is to set breakpoints on APIs that you know the progam calls from static/behavioral analysis.
    1. Run the program without breakpoints.
    2. Click the "Memory Tab" and look for segments that have "ERW" execute in the protection column
    3. For the example in class we hone in on NPX01 which was a section header we were pretty sure had unpacked code.
        - Confirm your suspicions by searching for string references or intermodular calls.
        - You can sort by name.
    4. For our purposes we can find decrypt in the intermodular calls, and double click it to follow in dissassembler.
    5. This time, set your breakpoint on the instruction afterward. You'll need to restart the program, but before that you need to set a hardware breakpoint (these are not overwritten like software breakpoints on restart).
    6. Restart and run debugger.

## Multi-Tech Malware
**Process Hacker/Monitor**

1. Run with process hacker and process monitor. Save process monitor as CSV.

**ProcDOT**

2. Load in procdot as listed above.
3. Look for red information boxes. 
4. Analyze .bat file in notepad. Looks like its trying to run a program
5. Analyze in notepad or PEStudio, looks like junk.
6. Return to procdot to review other elements and find the registry information.
    - Windows looks at the registry to figure out how to open specific extensions in HKCU\Software\Classes
    - The registry value shows you where to go in the registry. The value is 0346 so go there in HKCU\SOftware\Classes\0346
    - Details are a powershell command. Running JS, with an eval which has to be valid javascript code.
    - There is a line of code but the registry value isn't shown
    > TIP
    > ***
    > If regedit doesn't show a value because the entry is too big, ctrl + c and ctrl + v in a text editor.

**Code Review**

7. After pasting to notepad++ click "Plugins" at the top > Click JSTools > Click JSFormat
8. As before copy the below script to the top of the script
```js
original_eval = eval;
eval = function(input_string) {
  WScript.Echo(input_string);   //Changes eval, which runs JS commands, to a print statement so we get the deobf. code
  original_eval(input_string);
}    
```
9. Run the script `cscript file.js > file2.js`.
    - cscript is windows way to run JS outside the browser. Ourscript is just printing the deobfuscated code.
10. Format as JS again. You'll see code that saves a base 64encoded value as a variable and gets run in powershell.
11. Copy and paste the code into your decoder of choice to get the newly formatted code. 
    - In notepad++ you can go to plugins MIME Tools > Base64 Decode.

**Powershell**

12. The decoded text will give you a look at shellcode. To decode the shell code, save as a ps1 file and open in powershell_ise.
13. Set a breakpoint in powershell_ise after the shell code by right clicking the line and setting breakpoint.
14. Click debug and run.
15. In the command line at the bottom type:
    ```powershell
    [io.file]::WriteAllBytes('sc32.bin',$sc32)
    ```
**Examine Shell Code**

16. Get a sense for the shellcode code by running it in `scdbg`. Just drag, drop, and launch.
    - It will error because it doesn't have it's memory address. Where have we seen this problem before?
    - However, whats useful is noticing that it loads RegOpenKey from advapi.dll and not the standard kernel32.dll
17. Use `runsc32` to run the shellcode.
    ```bash
    runsc32 -f sc32.bin
    ```
18. Attach runsc32 to `x32dbg` > set breakpoint in dbg CLI at the bottom `setBPX 0xaddress`
19. Resume `runsc32` and review code. Set a new breakpoint at `advapi32.RegOpenKeyExA` > run debug
20. Follow the rest of the lab for doing the debugger on b4p89.
    - Essentially, you set different breakpoints at key parts and run until return, follow in dump 1 and 2 to see what is loaded into memory and then dump the executable as its own binary.
    - The goal here is to find what is being loaded into virtualalloc. Because we know this api is being called. So we set breakpoints on virtualalloc. Run until break, run until return, follow EAX (the return register) in dump, then run again.
        - The return has set the space.
        - The running the debug after (potentially to the next virtualalloc) will load that space.
    - You do NOT know how many time virtualalloc will be called.
21. Dump the executable you find by right clicking in the dump window > select "Follow in Memory Map" > right click the gray bar thats highlighted > select "Dump Memory to File"

**Dygert Recipe for checkbox**
```
Regular_expression('User defined','[a-zA-Z0-9+/=]{40,}',true,true,false,false,false,false,'List matches')
From_Base64('A-Za-z0-9+/=',true)
Decode_text('UTF-16LE (1200)')
Regular_expression('User defined','[a-zA-Z0-9+/=]{20,}',true,true,false,false,false,false,'List matches')
From_Base64('A-Za-z0-9+/=',true)
Gunzip()
Regular_expression('User defined','[a-zA-Z0-9+/=]{30,}',true,true,false,false,false,false,'List matches')
From_Base64('A-Za-z0-9+/=',true)
XOR({'option':'Decimal','string':'35'},'Standard',false)
```

## Examining .NET Malware
- Because its written without opcodes .NET framework benefits from using specialized tools different than what we have used previously.
- Much like eval, Whatever gets passed to load must be readable.

- Use ilspycmd file.exe > file.txt on RemNux to get initial details.
- Use `dnSpy32` on RemWindows to debug
    - Search through the modules based on intel you may have.
    - "^" is an XOR so that means decoding.
    - Set breakpoints on assemnly.load and run > save array to disk.
- `DotDumper -file mal.exe` can help with unpacking .NET malware.

## Understanding code injection
- I know what I must do, but I don't know if I have the strength to do it.

- To detect a malicious thread look for:
    - CreateToolhelp32Snapshot or EnumProcesses: NtQuerySystemInformation
    - OpenProcess: NtOpenProcess/ZwOpenProcess
    - VirtualAllocEx: NtAllocateVirtualMemory/ZwAllocateVirtualMemory
    - WriteProcessMemory: NtWriteVirtualMemory/ZwWriteVirtualMemory
    - CreateRemoteThread: NtCreateThreadEx/ZwCreateThreadEx

# Day 5

## Debugger Detection and Data Protection
- You want to be able to run the debugger to see what it loads into command.
- `IsDebuggerPresent` will return with 1 and test off that.
- You can't add lines of code affecting address, but you can modify the code in line as long as it matches the bytes within the address space.
- For example:
```s
#You cant do this
000000014000 | 85C0               | test eax,eax                   |
000000014000 | 0F85 E4010000      | jne getdown.140001216          |
#to this because it has more bytes
000000014000 | B8 000000          | mov eax,eax                    |
000000014000 | 0F85 E4010000      | jne getdown.140001216          |

``` 

- ON the line select what you want to change and hit `spacebar`
    - patch code with your entries.
    - Save the patches with file > patch file > patch file.

- Alternatively, right click line > click assemble > type NOP and check fill with NOPs
    - patch

- You can also use scylla hide:
    - Select all the options under debugger hiding.

- You could also change RAX/EAX to 0 in the registry which has the benefit of not being detected by malware.
- fs:[30h] is address of the PEB
    - Helpful to note the offests of PEB 
    - NtGlobal Flag b5p13

### Finding encoded data
- If initial static/behavioral analysis determined that the sample was using something like an IP but you can't find it in strings you may be dealing with encoded data.

**REMNUX Tools for encoded data**
```bash
# -i is case insensitive search and -s generates file that decodes all bytes using discovered key.
# You need to know what you're searching for. Command creates a file of with the key.
#Example
#xorsearch -i -s getdown.exe http:
xorsearch -i -s file.exe value      
```
```bash
# Use brxor.py to deobfuscate
brxor.py file.exe
```
```bash
# bbcrack attempts many transofrmations and ranks potentially deobfuscated patterns
# Creates a file based on potential matches.
bbcrack -l 1 file.exe       # -l 1 attempts only 1 level of transofrmations.
```
- Once you have a result from any of the above run strings against that file.

- For stack strings:
    - Note that hex values of ascii are between the range 0x20 and 0x7F
```bash
# Automatically decode stack strings
strdeob.pl file.exe
```
- Good regular option
```bash
floss file.exe
```
```bash
# Automatically locate and deobfuscate
floss --no static -- file.exe > flossfile.txt       # no static prevents looking at regular deobfuscated
```

**GHIDRA for stack strings**
- Authors will also encode data by pushing it onto the stack individually so it can't be detected by strings.
- Open file in ghidra, locate multiple move commands of hex values and convert each one to char
    - Open Edit > Tool Option > key bindings > and search for convert.
    - Set a key binding on Equate for faster conversion

**Additional settings for debugger**
- Don't break on exceptions b5p29.
- Authors will create exceptions that slow down the debugger.
- This should be standard practice because exceptions aren't often useful.

**Decompression in debugger**
- If you know a compression is available:
- With scylla settings turned on go to the decompression by looking at intermodule calls. Set a breakpoint on RtlDecompressBuffer.
    - This takes you to the function afer its been called.
- Follow ESB + 8 in dump: We know this from looking at the [documentation](https://learn.microsoft.com/en-us/windows-hardware/drivers/ddi/ntifs/nf-ntifs-rtldecompressbuffer).
    - The uncompressedbuffer **The decompressed information we need** is the second parameter. ESB+8 is listed as the second parameter in the "Default (stdcall)" window.
- Go to call stack to find the first user value > Follow to the first user value.
- You should see a call to the function right above meaning youve made it after the function return.
    - Run to selection > Step through until the value changes.
- Dump the file using the commands listed above [## Examining .NET Malware](/Malware_Analysis/FOR610_Notes.md/#examining-net-malware)

## Process Hollowing (Custom unpacking)
- Review labe from b5p46
- Find details in ghidra
- Open up debugger and investigate writeprocess memory.
- Reference the documentation again. THe third paramter of write process memory is whats juicy, follow it in the dump.

- API Calls to look for/signature of process hollowing:
    ```md
    1. CreateProcess or its variations: Launches a suspended child process; which program this is doesn't matter.
    2. NtUnmapViewOfSection or ZwUnmapViewOfSection: Deallocates (hollows out) virtual memory of the process.
    3. VirtualAllocEx or its variations: Allocates memory space in the child process to make room for the about-to-be-injected code.
    4. WriteProcessMemory or its variations: Writes (injects) new code into the new allocated memory of the child process.
    5. ResumeThread: Awakens the child process to run injected code. 
    ```

## Detecting analysis toolkit
**Looking at windows hooks**
- Again review documentation
- Windows mouse call calls a function every time the mouse is pressed.
- Label each function as you go.

**Moving through defenses with dbg**
- Pay attention to function calls that don't do anything with EAX as TEST or CMP.
- If you look for CALL sandwiches you might have a decoding routine.
- The stack is located in the bottom right hand corner of dbg.
- By stepping through the code we can see a decode function. Then we see it decoding the strings and calling EDI.
    - EDI has a function to getprocessname and is looking for the pressence of debuggers and comparing it. Exiting if true.
- Helpful tip, as youre stepping into functions, set a breakpoint after the call you're stepping into so you can return to it easier.
- When analyzing loops start at the bottom, the condition it's looking for.
- Focus on the calls and run until your selection.

## Misdirection Techniques
- Conceals jumps in exception handling. Try and Except is similar to 
- Pointer to first structure or first SEH record is stored in FS:[0] if you see this someone is trying to conceal a jump.
- Use the `seh` tab at the top of x32dbg to find the SEH structure.
    - You can also right click in "Watch" at the bottom and click add FS:[0]

- The unpacker is going to do its thing but it must use the stack to do it. SO we can set a breakpoint on the stack to see when it returns to that value.
- Step over program until you see the stack loaded. Right click the top of the stack and add a hardware access breakpoint (dword)
- Run the program looking at the name of the window until it leave ntdll. Ntdll will look at the stack so it will trip the breakpoint.

**TLS Callbacks**
- Using PEStudios you'll see TLSCallback you will see location of a TLS callback.
- When opening your dbg if you have "Stop at TLSCallback enabled" on preferences, it will take you to the TLS or you can go to the location in PESTudio.
- THis code is decoding its code, then re-encoding it later.
- MOV gs,ax when fs is 53 and ax is 53 its trying to change gs to fs
- Poping that into EDX means EDX holds the pointer to the handler
- SEH means, the address in the tab is where it goes when an error occurs. AN error could be an incorrect memmory address assignment.
- The code may also use a call to look at debuggers to produce a value, then divide by that value stored in a register. If there is no debugger present the code will error out and hit the SEH. However, if there is a debugger it will not error and not execute the code.

## Unpacking by Anticipating Actions
- We start by looking at LoadLibraryA
- Setting a breakpoint there, run it until you see an interesting DLL. Notice that the EIP doesn't change, thats because we keep coming back to the loadlibrary function but EAX is changing.
- Use call stack to follow to the first user call.
- Confirm its right by looking at the call.
- Click local tab at the bottom, then right click the line after the call and select "xanalyzer" > ANalyze function
- In the locals tab you'll see the local argument.
- Set BP on virtualProtect (one of the local arguments)
- Follow the page value of 2000.
- Run the debugger again and look at the locals again.
- The parameters show the 3rd parameter as 0x20 which is execute read for vritualprotect
- We need to let virtualprotect finish what it was doing to unpack the code.
- Run debugger until execute.
- With it on the return value, go to the dump and right click, set breakpoint > memory, execute, singleshot
- Run, and you'll confirm its done.
- Dump the prgoram but youre not done yet.

**PEUNMAPPER: move from memory to disk**
- If the code start 1000 after the header, its in the virtual format. In an administrative CMD Prompt
```bash
# Base should be the location of the address that you had in memory map.
# in need to take an exe, the .bin from the dump wont do.
pe_unmapper /in 06FD0000.exe /out yepdump.exe /base 400000
```
- Then go back to debugger to fix the dump as usual